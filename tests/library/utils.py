import re
from operator import itemgetter


def get_table_dict(table_obj) -> list:
    """
    Function to clean and format the table object into list of dictionaries
    :param table_obj: table data from web
    :return: list of table rows
    """
    # fetch the headers
    result_header = []
    table_headers = table_obj.find_elements_by_class_name('table-header')[0]
    for heading in table_headers.text.split(sep='\n'):
        result_header.append(heading.lower())

    # fetch each row data
    table_rows = table_obj.find_elements_by_class_name('table-row')

    # store the table response
    original_result = []
    if table_rows:
        each_row = {k: None for k in result_header}
        for row in table_rows:
            col = row.find_elements_by_class_name('table-data')
            for i in range(len(col)):
                each_row[result_header[i]] = col[i].text
            original_result.append(each_row.copy())
    return original_result


def create_expected_table_sorted(original_table: list, sort_data: str) -> list:
    """
    function to generate sorted table based on sorting column
    :param original_table: table with initial data
    :param sort_data: sort column
    :return: list of table row dictionary
    """
    if sort_data == 'name':
        new_list = sorted(original_table, key=lambda x: x[sort_data].lower())
    elif sort_data == 'complexity':
        complexity_weight = {'low': 1, 'medium': 2, 'high': 3}
        new_list = sorted(original_table, key=lambda x: x['name'].lower(), reverse=True)
        new_list = sorted(new_list, key=lambda x: complexity_weight[x[sort_data].lower()])
    elif sort_data == 'averageImpact':
        new_list = sorted(original_table, key=lambda x: float(x['average impact score']))
    elif sort_data == 'cases':
        modified_table = append_additional_parameter(original_table)
        new_list = sorted(modified_table, key=itemgetter(sort_data))
        new_list = remove_added_additional_parameter(new_list, sort_data)
    return new_list


def check_table_data(actual_table: list, expected_table: list) -> bool:
    """
    function to check actual table data match with expected table data
    :param actual_table: actual table generated by web
    :param expected_table: expected table as per sorting calculation
    :return: True if matches otherwise False
    """
    if len(actual_table) == len(expected_table):
        if len(actual_table) == 0:
            return True
        else:
            pairs = zip(actual_table, expected_table)
            return not (any(a != y for a, y in pairs))
    else:
        return False


def create_expected_table_search(original_table: list, search_data: str) -> list:
    """
    function to generate table based on search data provided by user
    :param original_table: table with initial data
    :param search_data: search text provided by user
    :return: list of table row dictionary
    """
    expected_list = [f for f in original_table
                     if re.search(search_data, f.get('name') + f.get('complexity'), re.IGNORECASE)]
    return expected_list


def append_additional_parameter(table_to_modify: list) -> list:
    """
    function appends parameter in table to handle sorting cases
    :param table_to_modify: list of table row dictionary
    :return: list of table row dictionary
    """
    for each_row in table_to_modify:
        cases = 0
        cases_text = each_row.get('number of cases')
        end_index = cases_text[-1]
        if end_index.isalpha():
            cases = float(cases_text[:-1])
            if end_index == 'k':
                cases = cases * pow(10, 3)
            elif end_index == 'M':
                cases = cases * pow(10, 6)
            elif end_index == 'B':
                cases = cases * pow(10, 9)
        else:
            cases = float(cases_text)
        each_row.update({'cases': cases})
    return table_to_modify


def remove_added_additional_parameter(table_to_modify: list, key_to_remove: str) -> list:
    """
    function will remove additional parameter added in table to handle sorting cases
    :param table_to_modify: list of table row dictionary
    :param key_to_remove: key string
    :return: list of table row dictionary
    """
    for each_row in table_to_modify:
        del each_row[key_to_remove]
    return table_to_modify
